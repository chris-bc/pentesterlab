from time import gmtime, strftime
from socket import *
import os

def handle(sock, addr):
	print 'Handling request from ' + repr(addr) + ' on PID ' + repr(os.getpid())
	data = sock.recv(BUFFSIZE)
	# Increasingly-complex condition here. 
	# Terminate where packet includes two CRLF sequences or 
	# (assuming the prev packet ended with CRLF) the packet 
	# *begins* with CRLF.
	while len(data) > 0 and data.find('\r\n\r\n') < 0 and data.find('\r\n') != 0:
		print repr(addr) + ' says: ' + data
		data = sock.recv(BUFFSIZE)
	# Print final line of input
	if len(data) > 0:
		print repr(addr) + ' says: ' + data
	htmlPayload = "<html><head><title>Server Test</title></head><body><h3>Server is working</h3><p>The server actually works</p></body></html>"
	sock.sendall('HTTP/1.1 200 OK\r\n' + strftime("%a, %d %b %Y %X %Z", gmtime()) + '\r\nServer: Crap HTTPD\r\nContent-Length: ' + repr(len(htmlPayload)) + '\r\nContent-type: text/html; charset=UTF-8\r\n\r\n' + htmlPayload + '\r\n')
	sock.close()

PORT = 8080
HOST = '127.0.0.1'
BUFFSIZE = 1024

serverSock = socket(AF_INET, SOCK_STREAM)
serverSock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
serverSock.bind((HOST,PORT))
serverSock.listen(5)

try:
	
	while True:
		print 'Listening on ' + HOST + ':' + repr(PORT)
		clientSock, clientAddr = serverSock.accept()
		print 'Connection received from ' + repr(clientAddr) + ', forking'
		if os.fork() == 0:
			handle(clientSock, clientAddr)
			os._exit(0)
except KeyboardInterrupt:
	print '\r\n^C received. Shutting down...'
	serverSock.close()

